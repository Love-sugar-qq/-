<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>For QingQing ‚ù§Ô∏è</title>
    <style>
        /* Âü∫Á°ÄËÆæÁΩÆ */
        body { 
            margin: 0; overflow: hidden; background-color: #020202; 
            font-family: 'Helvetica Neue', sans-serif;
            touch-action: none; 
            -webkit-user-select: none; user-select: none;
            -webkit-touch-callout: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 10px; box-sizing: border-box;
            opacity: 0; transition: opacity 1s; pointer-events: none;
        }
        
        /* ÂÖÅËÆ∏‰∫§‰∫íÁöÑÂå∫Âüü */
        .top-bar, .controls, #lock-screen { pointer-events: auto; }

        /* ÂØÜÁ†ÅÈîÅÂ±è */
        #lock-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #FFD700; transition: opacity 0.8s;
        }
        .lock-title { font-size: 20px; margin-bottom: 20px; letter-spacing: 2px; }
        .lock-input {
            padding: 10px; border: 2px solid #FF1493; background: transparent; 
            color: white; border-radius: 8px; outline: none; text-align: center;
            font-size: 16px; width: 150px; margin-bottom: 15px;
        }
        .lock-btn {
            background: #FF1493; color: white; border: none; padding: 10px 30px;
            border-radius: 50px; font-weight: bold; cursor: pointer;
        }
        .error-msg { color: red; font-size: 12px; margin-top: 10px; height: 15px; }
        /* Âä†ËΩΩËøõÂ∫¶ÊèêÁ§∫ */
        #loading-text { margin-top: 20px; font-size: 12px; color: #aaa; letter-spacing: 1px; }

        .top-bar { display: flex; justify-content: flex-end; align-items: flex-start; }
        .mode-switch {
            background: rgba(255,255,255,0.15); backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 15px; padding: 3px; display: flex; gap: 3px;
        }
        .mode-btn {
            background: transparent; border: none; color: #aaa; padding: 5px 10px; font-size: 10px; font-weight: bold;
            border-radius: 12px; cursor: pointer; transition: all 0.2s;
        }
        .mode-btn.active { background: #FF1493; color: white; }

        #guide {
            position: absolute; bottom: 85px; left: 10px; width: 110px; 
            color: rgba(255,255,255,0.7); font-size: 10px; line-height: 1.4;
            background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;
            border-left: 2px solid #FFD700; pointer-events: none;
        }
        .key { color: #FFD700; font-weight: bold; }
        .guide-row { margin-bottom: 2px; }
        
        .controls { 
            text-align: center; margin-bottom: 15px; 
            display: flex; justify-content: center; gap: 8px; 
        }
        .btn-main {
            background: linear-gradient(135deg, #FF1493, #FFD700);
            border: none; color: #fff; padding: 10px 15px; 
            text-transform: uppercase; font-size: 11px; border-radius: 50px;
            box-shadow: 0 4px 10px rgba(255, 20, 147, 0.4); font-weight: bold; white-space: nowrap;
        }
        .btn-sub {
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.2);
            color: #ccc; padding: 10px 12px; font-size: 11px; border-radius: 50px; backdrop-filter: blur(5px);
        }
        
        #btn-folder-upload { display: none; }
        @media (min-width: 768px) { #btn-folder-upload { display: inline-block; } }
        
        #file-input, #folder-input { display: none; }
        #status { position: absolute; bottom: 5px; left: 10px; color: rgba(255,255,255,0.4); font-size: 9px; pointer-events: none; }
        #input_video { display: none; }
    </style>
</head>
<body>

    <div id="lock-screen">
        <div class="lock-title">üéÑ FOR QINGQING ‚ù§Ô∏è</div>
        <input type="password" id="password-input" class="lock-input" placeholder="ËæìÂÖ•Êàë‰ª¨ÁöÑÁ∫™ÂøµÊó•">
        <button class="lock-btn" onclick="checkPassword()">ÂºÄÂêØÊÉäÂñú</button>
        <div class="error-msg" id="error-msg"></div>
        <div id="loading-text"></div>
    </div>

    <video id="input_video" autoplay playsinline></video>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="mode-switch">
                <button class="mode-btn active" id="btn-touch" onclick="setMode('TOUCH')">üëÜ Ëß¶Â±è</button>
                <button class="mode-btn" id="btn-hands" onclick="setMode('HANDS')">üëã ÊâãÂäø</button>
            </div>
        </div>

        <div id="guide">
            <div class="guide-row"><span class="key">üëÜ ÊãñÂä®</span> 360¬∞ÊóãËΩ¨</div>
            <div class="guide-row"><span class="key">‚úåÔ∏è ÂèåÂáª</span> Êï£ÂºÄ/ËÅöÊã¢</div>
            <div class="guide-row"><span class="key">ü§è ÊçèÂêà</span> Ê†ëÂΩ¢/ÂèòÂ§ß</div>
            <div class="guide-row"><span class="key">üëã ÊëáÊôÉ</span> ÊäΩÂèñÁÖßÁâá</div>
            <div style="margin-top:4px; color:#aaa;">ÁÇπÂáªÁÖßÁâáÊîæÂ§ß</div>
        </div>
        
        <div class="controls">
            <button class="btn-main" onclick="document.getElementById('file-input').click()">+ ÂØºÂÖ•ÁÖßÁâá(Â§öÈÄâ)</button>
            <button class="btn-main" id="btn-folder-upload" onclick="document.getElementById('folder-input').click()">+ Êñá‰ª∂Â§π</button>
            <button class="btn-sub" id="btn-shake" style="display:none;" onclick="requestMotion()">‚ö° Êëá‰∏ÄÊëá</button>
            
            <input type="file" id="file-input" accept="image/*" multiple onchange="handlePhotoUpload(this)">
            <input type="file" id="folder-input" webkitdirectory directory multiple onchange="handlePhotoUpload(this)">
        </div>
        
        <div id="status">v47.0 Turbo Mode</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 0. CONFIG ---
        const CORRECT_PASSWORD = "0319"; 
        const SECRET_FOLDER = "secret_love_hxq"; 
        const TOTAL_PRELOAD_IMAGES = 80;

        function checkPassword() {
            const input = document.getElementById('password-input').value;
            if (input === CORRECT_PASSWORD) {
                // UI Feedback
                document.getElementById('loading-text').innerText = "ÊûÅÈÄüÂä†ËΩΩÂõûÂøÜ‰∏≠...";
                const lockScreen = document.getElementById('lock-screen');
                const uiLayer = document.getElementById('ui-layer');
                
                // Unlock immediately
                lockScreen.style.opacity = 0;
                setTimeout(() => lockScreen.style.display = 'none', 800);
                uiLayer.style.opacity = 1;
                
                // Start Turbo Load
                preloadPhotosTurbo();
                
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    document.getElementById('btn-shake').style.display = 'block';
                }
            } else {
                document.getElementById('error-msg').innerText = "ÂØÜÁ†ÅÈîôËØØÔºåËØ∑ÈáçËØï ‚ù§Ô∏è";
            }
        }

        // --- 1. SETTINGS ---
        const isMobile = window.innerWidth < 768; 
        const config = {
            decoCount: isMobile ? 800 : 1500, 
            treeDustCount: isMobile ? 1000 : 2500,
            rootDustCount: isMobile ? 300 : 800,
            orbitDustCount: isMobile ? 500 : 1200, 
            bgDustCount: isMobile ? 600 : 1500, 
            heartCount: isMobile ? 50 : 100,
            photoCount: 80, 
            photoBrightness: 0xdddddd, 
            hudPhotoBrightness: 0x888888, 
            topText: "Êô¥Êô¥Âú£ËØûËäÇÂø´‰πêÔºÅ",
            bgTexts: ["ÊúÄÁà±Êô¥Êô¥", "Â§©Áß§Â∫ß&&Ê∞¥Áì∂Â∫ß", "ÂèØÁà±ÁöÑÂÆùÂÆù", "Áà±‰Ω†‰∏ÄÁîü‰∏Ä‰∏ñ", "I LOVE YOU", "3.19", "2.10", "10.18", "Êàë‰ª¨‰∏ÄÁõ¥Âú®‰∏ÄËµ∑", "‰∏ÄÁõ¥Âà∞ÁªìÂ©ö"],
            colors: {
                gold: 0xFFE55C, red: 0xFF3355, greenD: 0x1a5e35, greenL: 0x52a86e,
                pink: 0xFF88C2, purple: 0xB090FF, blue: 0x33CCFF, yellow: 0xFFFF66,
                libraGold: 0xFFE55C, aquaBlue: 0x33CCFF
            },
            treeHeight: 80, treeRadius: isMobile ? 25 : 35, scatterRadius: 120
        };

        const state = {
            mode: 'TREE', inputMode: 'TOUCH', isInspecting: false,
            unviewedPhotos: [], isGrabLocked: false, album: [], uploadIndex: 0
        };

        function resetDeck() {
            state.unviewedPhotos = Array.from({length: config.photoCount}, (_, i) => i);
            for (let i = state.unviewedPhotos.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [state.unviewedPhotos[i], state.unviewedPhotos[j]] = [state.unviewedPhotos[j], state.unviewedPhotos[i]];
            }
        }
        resetDeck();

        // --- 2. THREE.JS ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.003);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, isMobile ? 140 : 120);
        camera.lookAt(0,0,0);
        scene.add(camera);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.toneMapping = THREE.ReinhardToneMapping; 
        renderer.toneMappingExposure = 1.5;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const mainLight = new THREE.PointLight(config.colors.gold, 2.0, 300);
        mainLight.position.set(20, 60, 40);
        scene.add(mainLight);
        const secondaryLight = new THREE.PointLight(config.colors.pink, 1.5, 300);
        secondaryLight.position.set(-30, 20, -40);
        scene.add(secondaryLight);

        let composer;
        try {
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; bloomPass.strength = 1.5; bloomPass.radius = 0.7;
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        } catch(e){}

        const mainGroup = new THREE.Group(); scene.add(mainGroup); 
        const staticGroup = new THREE.Group(); scene.add(staticGroup); 
        const orbitGroup = new THREE.Group(); scene.add(orbitGroup);
        const heartGroup = new THREE.Group(); staticGroup.add(heartGroup);
        const constellationGroup = new THREE.Group(); staticGroup.add(constellationGroup);
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const hudGroup = new THREE.Group();
        camera.add(hudGroup);
        const hudGeometry = new THREE.PlaneGeometry(12, 16); 
        const hudMaterial = new THREE.MeshBasicMaterial({ 
            color: config.hudPhotoBrightness, side: THREE.DoubleSide, transparent: false, depthTest: false, depthWrite: false
        });
        const hudMesh = new THREE.Mesh(hudGeometry, hudMaterial);
        hudMesh.position.set(0, 0, -15); hudMesh.renderOrder = 9999; hudGroup.add(hudMesh);
        hudGroup.visible = false;

        const borderGeo = new THREE.PlaneGeometry(12.5, 16.5);
        const brightGold = new THREE.Color(0xFFD700).multiplyScalar(2.0); 
        const borderMat = new THREE.MeshBasicMaterial({ color: brightGold, side: THREE.DoubleSide, depthTest:false, depthWrite:false });
        const borderMesh = new THREE.Mesh(borderGeo, borderMat);
        borderMesh.position.set(0, 0, -15.1); borderMesh.renderOrder = 9998; hudGroup.add(borderMesh);

        // Assets
        const geoSphere = new THREE.IcosahedronGeometry(0.8, 1);
        const geoBox = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const geoTorus = new THREE.TorusGeometry(0.7, 0.25, 12, 24);
        const geoDust = new THREE.TetrahedronGeometry(0.3, 0);

        const matGold = new THREE.MeshStandardMaterial({ color: config.colors.gold, roughness: 0.1, metalness: 1.0, emissive: 0x554400, emissiveIntensity: 1.2 });
        const matRed = new THREE.MeshStandardMaterial({ color: config.colors.red, roughness: 0.15, metalness: 0.8, emissive: 0x660000, emissiveIntensity: 1.0 });
        const matGreenD = new THREE.MeshStandardMaterial({ color: config.colors.greenD, roughness: 0.4, metalness: 0.3 });
        const matGreenL = new THREE.MeshStandardMaterial({ color: config.colors.greenL, roughness: 0.3, metalness: 0.4 });
        const matDustGold = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        
        const particles = [];
        const photoParticles = []; 
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        function getTreePos(i, total, radiusMod = 1, heightMod = 1, hOffset = 0) {
            const h = config.treeHeight * heightMod;
            const t = i / total;
            const y = h * (t - 0.5) + hOffset;
            const progressFromTop = 1 - t;
            let rProfile = Math.pow(progressFromTop, 0.85) * config.treeRadius * radiusMod; 
            rProfile += 0.5; 
            const angle = i * goldenAngle;
            const jitterRadius = rProfile + (Math.random() - 0.5) * 1.5; 
            return new THREE.Vector3(Math.cos(angle) * jitterRadius, y, Math.sin(angle) * jitterRadius);
        }

        function getScatterPos(radius = config.scatterRadius) {
            const u = Math.random(); const v = Math.random();
            const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
            const r = radius * (0.4 + Math.random() * 0.8);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        }
        
        function getCircleTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient; context.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        const circleTex = getCircleTexture();

        (function createTopTextParticles() {
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 90px "Times New Roman", serif'; 
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(config.topText, canvas.width / 2, canvas.height / 2);
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

             for (let y = 0; y < canvas.height; y += 3) {
                for (let x = 0; x < canvas.width; x += 3) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 128) {
                        const mesh = new THREE.Sprite(new THREE.SpriteMaterial({
                            map: circleTex, color: config.colors.gold, transparent: true, blending: THREE.AdditiveBlending
                        }));
                        mesh.scale.set(0.8, 0.8, 0.8);
                        const jX = (Math.random()-0.5)*0.5; const jY = (Math.random()-0.5)*0.5; const jZ = (Math.random()-0.5)*2.0;
                        const pX = (x - canvas.width / 2) * 0.12 + jX;
                        const pY = (canvas.height / 2 - y) * 0.12 + 65 + jY;
                        const pZ = Math.sin(x * 0.02) * 3 - 10 + jZ;
                        const treePos = new THREE.Vector3(pX, pY, pZ);
                        const scatterPos = getScatterPos(140);
                        mesh.position.copy(treePos);
                        staticGroup.add(mesh); 
                        particles.push({mesh, treePos, scatterPos, type:'text', originalScale:new THREE.Vector3(0.8,0.8,0.8)});
                    }
                }
            }
        })();

        for(let i=0; i<config.decoCount; i++) {
            let mesh; const r=Math.random();
            if(r>0.85) mesh=new THREE.Mesh(geoBox, matGold);
            else if(r>0.7) mesh=new THREE.Mesh(geoTorus, matRed);
            else if(r>0.4) mesh=new THREE.Mesh(geoSphere, matGreenD);
            else mesh=new THREE.Mesh(geoSphere, matGreenL);
            const treePos=getTreePos(i, config.decoCount);
            treePos.x+=(Math.random()-0.5)*1.0; treePos.z+=(Math.random()-0.5)*1.0;
            mesh.position.copy(treePos); mesh.scale.setScalar(Math.random()*0.7+0.6);
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            mainGroup.add(mesh);
            particles.push({mesh, treePos, scatterPos:getScatterPos(), type:'deco', originalScale:mesh.scale.clone()});
        }
        for(let i=0; i<config.treeDustCount; i++) {
            const mesh=new THREE.Mesh(geoDust, matDustGold);
            const treePos=getTreePos(i, config.treeDustCount, 1.0, 1.05); 
            treePos.x+=(Math.random()-0.5)*2; treePos.y+=(Math.random()-0.5)*2; treePos.z+=(Math.random()-0.5)*2;
            mesh.position.copy(treePos); mesh.scale.setScalar(Math.random()*0.5+0.2); mainGroup.add(mesh);
            particles.push({mesh, treePos, scatterPos:getScatterPos(120), type:'dust', originalScale:mesh.scale.clone()});
        }
        
        const orbitGeoSys=new THREE.BufferGeometry(); const orbitPosArr=[]; const orbitColArr=[];
        const orbitColors=[new THREE.Color(config.colors.gold), new THREE.Color(config.colors.pink), new THREE.Color(config.colors.blue)];
        for(let i=0; i<config.orbitDustCount; i++) {
            const r=config.treeRadius*(1.3+Math.random()*0.9);
            const angle=Math.random()*Math.PI*2;
            const y=(Math.random()-0.5)*config.treeHeight*1.6;
            orbitPosArr.push(r*Math.cos(angle), y, r*Math.sin(angle));
            const c=orbitColors[Math.floor(Math.random()*orbitColors.length)];
            orbitColArr.push(c.r*1.5, c.g*1.5, c.b*1.5);
        }
        orbitGeoSys.setAttribute('position', new THREE.Float32BufferAttribute(orbitPosArr, 3));
        orbitGeoSys.setAttribute('color', new THREE.Float32BufferAttribute(orbitColArr, 3));
        orbitGroup.add(new THREE.Points(orbitGeoSys, new THREE.PointsMaterial({size:1.2, vertexColors:true, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending})));

        const bgGeo=new THREE.BufferGeometry(); const bgPos=[]; const bgCols=[];
        const bgBaseCols=[new THREE.Color(config.colors.pink), new THREE.Color(config.colors.purple), new THREE.Color(config.colors.blue)];
        for(let i=0; i<config.bgDustCount; i++) {
            const r = 200 * Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            bgPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi) - 100);
            const c=bgBaseCols[Math.floor(Math.random()*bgBaseCols.length)];
            bgCols.push(c.r*1.3, c.g*1.3, c.b*1.3);
        }
        bgGeo.setAttribute('position', new THREE.Float32BufferAttribute(bgPos, 3));
        bgGeo.setAttribute('color', new THREE.Float32BufferAttribute(bgCols, 3));
        scene.add(new THREE.Points(bgGeo, new THREE.PointsMaterial({size:1.0, vertexColors:true, transparent:true, opacity:0.6, blending:THREE.AdditiveBlending})));

        const topStar=new THREE.Mesh(new THREE.OctahedronGeometry(4, 0), new THREE.MeshStandardMaterial({color:0xFFFDD0, emissive:0xAAAA00, metalness:1.0, roughness:0.1}));
        topStar.position.set(0, config.treeHeight/2+5, 0); mainGroup.add(topStar); topStar.add(new THREE.PointLight(0xFFD700, 3, 100));

        function createTextTexture(text, color) {
            const canvas=document.createElement('canvas'); canvas.width=512; canvas.height=128;
            const ctx=canvas.getContext('2d');
            ctx.font='bold 50px "Microsoft YaHei", Arial';
            ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.shadowColor=color; ctx.shadowBlur=25; 
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            return new THREE.CanvasTexture(canvas);
        }
        config.bgTexts.forEach(text => {
            const tex=createTextTexture(text, '#FF88C2');
            const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false});
            const geo=new THREE.PlaneGeometry(40, 10); const mesh=new THREE.Mesh(geo, mat);
            mesh.position.set((Math.random()-0.5)*300, (Math.random()-0.5)*200, -150); 
            mesh.lookAt(camera.position); staticGroup.add(mesh);
        });
        const heartShape=new THREE.Shape();
        heartShape.moveTo(25, 25); heartShape.bezierCurveTo(25, 25, 20, 0, 0, 0); heartShape.bezierCurveTo(-30, 0, -30, 35, -30, 35);
        heartShape.bezierCurveTo(-30, 55, -10, 77, 25, 95); heartShape.bezierCurveTo(60, 77, 80, 55, 80, 35);
        heartShape.bezierCurveTo(80, 35, 80, 0, 50, 0); heartShape.bezierCurveTo(35, 0, 25, 25, 25, 25);
        const heartGeo=new THREE.ShapeGeometry(heartShape);
        const heartMat=new THREE.MeshBasicMaterial({color:new THREE.Color(config.colors.yellow).multiplyScalar(1.2), transparent:true, opacity:0.7, blending: THREE.AdditiveBlending});
        for(let i=0; i<config.heartCount; i++) {
            const mesh=new THREE.Mesh(heartGeo, heartMat);
            mesh.position.set((Math.random()-0.5)*200, (Math.random()-0.5)*200, -100); 
            mesh.scale.setScalar(0.02+Math.random()*0.02);
            mesh.rotation.z=(Math.random()-0.5)*0.5; heartGroup.add(mesh);
            mesh.userData.baseScale=mesh.scale.x; mesh.userData.pulseOffset=Math.random()*Math.PI*2;
        }

        function createPlaceholderTexture(index) {
            const cvs=document.createElement('canvas'); cvs.width=300; cvs.height=400; const cx=cvs.getContext('2d');
            const hue=(index*360/config.photoCount)%360; const grad=cx.createLinearGradient(0,0,300,400);
            grad.addColorStop(0, `hsla(${hue}, 50%, 30%, 1)`); grad.addColorStop(1, `hsla(${hue+30}, 50%, 20%, 1)`);
            cx.fillStyle=grad; cx.fillRect(0,0,300,400);
            cx.strokeStyle='rgba(255,255,255,0.3)'; cx.lineWidth=3; cx.strokeRect(10,10,280,380);
            cx.fillStyle='rgba(255,255,255,0.8)'; cx.font='bold 40px Arial'; cx.textAlign='center';
            cx.fillText('Photo '+ (index+1), 150, 200); cx.font='20px Arial'; cx.fillText('Waiting...', 150, 240);
            return new THREE.CanvasTexture(cvs);
        }
        const photoGeo=new THREE.PlaneGeometry(6, 8);
        for(let i=0; i<config.photoCount; i++) {
            const tex=createPlaceholderTexture(i);
            state.album.push(tex); 
            const mat=new THREE.MeshBasicMaterial({color:config.photoBrightness, side:THREE.DoubleSide, map:tex});
            const mesh=new THREE.Mesh(photoGeo, mat);
            const indexInTree=Math.floor((i/config.photoCount)*config.decoCount);
            const treePos=getTreePos(indexInTree, config.decoCount, 1.4, 0.9);
            mesh.position.copy(treePos); mainGroup.add(mesh);
            mesh.userData = { id: i }; 
            const pObj={mesh, treePos, scatterPos:getScatterPos(), isPhoto:true, originalScale:new THREE.Vector3(1,1,1), id:i};
            particles.push(pObj); photoParticles.push(pObj);
        }

        // --- ‚òÖ‚òÖ‚òÖ TURBO PRELOAD (ASYNC + BITMAP) ‚òÖ‚òÖ‚òÖ ---
        function preloadPhotosTurbo() {
            let loadedCount = 0;
            const statusEl = document.getElementById('status');
            const loadingText = document.getElementById('loading-text'); // If lock screen still visible

            for(let i = 1; i <= TOTAL_PRELOAD_IMAGES; i++) {
                const imgUrl = `${SECRET_FOLDER}/${i}.jpg`;
                
                // Fetch -> Blob -> Bitmap (Backgroud Thread)
                fetch(imgUrl)
                    .then(res => {
                        if (!res.ok) throw new Error("404");
                        return res.blob();
                    })
                    .then(blob => createImageBitmap(blob, { 
                        // Downscale to 256x256 for speed & memory
                        resizeWidth: 256, resizeHeight: 256, resizeQuality: 'medium' 
                    }))
                    .then(bitmap => {
                        const tex = new THREE.CanvasTexture(bitmap);
                        tex.encoding = THREE.sRGBEncoding;
                        // Important: Free memory when updated
                        tex.onUpdate = () => { bitmap.close(); }; 

                        const slotIndex = (i - 1) % config.photoCount;
                        state.album[slotIndex] = tex;
                        
                        const slot = photoParticles[slotIndex];
                        if(slot && slot.mesh) {
                            slot.mesh.material.map = tex;
                            slot.mesh.material.needsUpdate = true;
                            slot.mesh.material.color.setHex(config.photoBrightness);
                        }
                        
                        loadedCount++;
                        if(statusEl) statusEl.innerText = `Loaded: ${loadedCount}/${TOTAL_PRELOAD_IMAGES}`;
                    })
                    .catch(err => { 
                        // console.log("Missing:", imgUrl); 
                    });
            }
        }

        // --- INTERACTIONS ---
        function transitionTo(newState) {
            if(state.mode === newState) return;
            state.mode = newState;
            particles.forEach(p => {
                let target = (newState === 'TREE') ? p.treePos : p.scatterPos;
                const dur = 1.5 + Math.random()*0.8;
                gsap.to(p.mesh.position, { x: target.x, y: target.y, z: target.z, duration: dur, ease: "power3.inOut" });
                if(p.type === 'text') {
                    if(newState !== 'TREE') gsap.to(p.mesh.lookAt, { duration: 1 });
                    else gsap.to(p.mesh.rotation, {x:0, y:0, z:0, duration: 1});
                }
            });
        }

        function showRandomPhoto() {
            if(state.isInspecting) return;
            if(state.unviewedPhotos.length === 0) resetDeck();
            
            const nextId = state.unviewedPhotos.pop();
            const tex = state.album[nextId];
            if(tex) {
                hudMesh.material.map = tex;
                hudMesh.material.color.setHex(config.hudPhotoBrightness); 
                hudMesh.material.needsUpdate = true;
            }
            state.isInspecting = true;
            hudGroup.visible = true;
            hudGroup.scale.set(0.1, 0.1, 0.1);
            gsap.to(hudGroup.scale, { x: 1, y: 1, z: 1, duration: 0.6, ease: "back.out(1.7)" });
        }

        function inspectPhoto(id) {
            if(state.isInspecting) return;
            const tex = state.album[id];
            if(tex) {
                hudMesh.material.map = tex;
                hudMesh.material.color.setHex(config.hudPhotoBrightness);
                hudMesh.material.needsUpdate = true;
                state.isInspecting = true;
                hudGroup.visible = true;
                hudGroup.scale.set(0.1, 0.1, 0.1);
                gsap.to(hudGroup.scale, { x: 1, y: 1, z: 1, duration: 0.6, ease: "back.out(1.7)" });
            }
        }

        function closePhoto() {
            if(!state.isInspecting) return;
            state.isInspecting = false;
            gsap.to(hudGroup.scale, { x: 0.1, y: 0.1, z: 0.1, duration: 0.3, onComplete: () => { hudGroup.visible = false; } });
        }

        window.setMode = (mode) => {
            state.inputMode = mode;
            const btns = document.querySelectorAll('.mode-btn');
            btns.forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            if(mode === 'HANDS') { cameraUtils.start().catch(e => console.log("Cam error", e)); } 
            else { cameraUtils.stop(); }
        };

        let lastX, lastY, lastZ;
        let lastShakeTime = 0;
        const shakeThreshold = 15;

        function requestMotion() {
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(resp => {
                    if(resp === 'granted') window.addEventListener('devicemotion', handleMotion);
                }).catch(console.error);
            }
        }
        function handleMotion(e) {
            if(state.inputMode !== 'TOUCH') return;
            const acc = e.accelerationIncludingGravity;
            if(!acc) return;
            const now = Date.now();
            if(now - lastShakeTime < 1500) return; 
            const deltaX = Math.abs(acc.x - lastX);
            const deltaY = Math.abs(acc.y - lastY);
            const deltaZ = Math.abs(acc.z - lastZ);
            if(deltaX + deltaY + deltaZ > shakeThreshold) {
                if(!state.isInspecting) { showRandomPhoto(); lastShakeTime = now; }
            }
            lastX = acc.x; lastY = acc.y; lastZ = acc.z;
        }
        window.addEventListener('devicemotion', handleMotion);

        // --- TOUCH LOGIC ---
        let lastTapTime = 0;
        let initialPinchDist = null;
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        const touchSurface = document.getElementById('canvas-container');

        touchSurface.addEventListener('touchstart', (e) => {
            if(state.inputMode !== 'TOUCH') return;
            if (e.touches.length === 1) {
                const now = Date.now();
                isDragging = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
                if (now - lastTapTime < 300) {
                    if(state.mode === 'TREE') transitionTo('SCATTER'); else transitionTo('TREE');
                }
                lastTapTime = now;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialPinchDist = Math.sqrt(dx*dx + dy*dy);
            }
        }, {passive: false});

        touchSurface.addEventListener('touchmove', (e) => {
            if(state.inputMode !== 'TOUCH') return;
            e.preventDefault(); 
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                mainGroup.rotation.y += deltaX * 0.005; 
                mainGroup.rotation.x += deltaY * 0.005; 
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2 && initialPinchDist) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDist = Math.sqrt(dx*dx + dy*dy);
                if (currentDist < initialPinchDist - 50) { transitionTo('TREE'); initialPinchDist = null; }
            }
        }, {passive: false});

        touchSurface.addEventListener('touchend', (e) => {
            if(state.inputMode !== 'TOUCH') return;
            isDragging = false;
            initialPinchDist = null;
            if (e.changedTouches.length === 1) {
                const touch = e.changedTouches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                if (state.isInspecting) { closePhoto(); return; }
                const intersects = raycaster.intersectObjects(photoParticles.map(p => p.mesh));
                if (intersects.length > 0) {
                    const id = intersects[0].object.userData.id;
                    inspectPhoto(id);
                }
            }
        });

        // --- MANUAL UPLOAD (Optimized) ---
        window.handlePhotoUpload = (input) => {
            if(!input.files.length) return;
            const files = Array.from(input.files).slice(0, 80); 
            files.forEach(file => {
                if (!file.type.startsWith('image/')) return;
                createImageBitmap(file, { resizeWidth: 256, resizeHeight: 256, resizeQuality: 'medium' })
                .then(bitmap => {
                    const tex = new THREE.CanvasTexture(bitmap);
                    tex.encoding = THREE.sRGBEncoding;
                    tex.onUpdate = () => { bitmap.close(); };
                    state.album[state.uploadIndex % config.photoCount] = tex;
                    const slot = photoParticles[state.uploadIndex % config.photoCount];
                    if(slot && slot.mesh) {
                        slot.mesh.material.map = tex; 
                        slot.mesh.material.needsUpdate = true;
                        slot.mesh.material.color.setHex(config.photoBrightness); 
                    }
                    state.uploadIndex++;
                });
            });
            alert("üéâ Â∑≤ÂØºÂÖ• " + files.length + " Âº†ÁÖßÁâáÔºÅ");
        };

        // --- HANDS ---
        function onResults(results) {
            if(state.inputMode !== 'HANDS') return;
            let rightHand = null, leftHand = null;
            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const label = results.multiHandedness[i].label;
                    if(label === 'Right') rightHand = results.multiHandLandmarks[i];
                    if(label === 'Left') leftHand = results.multiHandLandmarks[i];
                }
            }
            if (rightHand) {
                const wrist = rightHand[0]; let extended = 0;
                [8,12,16,20].forEach(i => {
                    const tip = rightHand[i]; 
                    if(Math.sqrt(Math.pow(tip.x-wrist.x,2)+Math.pow(tip.y-wrist.y,2)) > 0.15) extended++;
                });
                if (extended <= 1) transitionTo('TREE'); else if (extended >= 4) transitionTo('SCATTER');
            }
            if (leftHand) {
                const wrist = leftHand[0]; const thumbTip = leftHand[4]; const indexTip = leftHand[8];
                let foldedCount = 0;
                [12, 16, 20].forEach(i => {
                    const tip = leftHand[i]; 
                    if(Math.sqrt(Math.pow(tip.x-wrist.x,2)+Math.pow(tip.y-wrist.y,2)) < 0.15) foldedCount++;
                });
                const isFist = foldedCount >= 3; 
                let extendedCount = 0;
                [8,12,16,20].forEach(i => {
                    const tip = leftHand[i]; 
                    if(Math.sqrt(Math.pow(tip.x-wrist.x,2)+Math.pow(tip.y-wrist.y,2)) > 0.15) extendedCount++;
                });
                const isOpen = extendedCount >= 4;
                if (isFist) {
                    if (!state.isInspecting && !state.isGrabLocked) {
                        state.isGrabLocked = true; showRandomPhoto(); setTimeout(() => state.isGrabLocked = false, 1500);
                    }
                } else if (isOpen) {
                    if (state.isInspecting && !state.isGrabLocked) { closePhoto(); }
                }
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const video = document.getElementById('input_video');
        const cameraUtils = new Camera(video, {
            onFrame: async () => { await hands.send({image: video}); },
            width: isMobile ? 360 : 640, height: isMobile ? 240 : 480, facingMode: 'user'
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (state.mode !== 'TREE' && !state.leftHandPinching) mainGroup.rotation.y += 0.001;
            else if (state.mode === 'TREE') { 
                if(!isDragging && state.inputMode === 'TOUCH') mainGroup.rotation.y += 0.002;
            }

            orbitGroup.rotation.y = time * -0.1; orbitGroup.rotation.z = Math.sin(time*0.5) * 0.05;
            topStar.rotation.y = time * 1.5;
            
            heartGroup.children.forEach(h => {
                const scale = h.userData.baseScale * (1 + Math.sin(time * 3 + h.userData.pulseOffset) * 0.2);
                h.scale.setScalar(scale);
            });
            constellationGroup.children.forEach(c => {
                 c.position.y += Math.sin(time * c.userData.floatSpeed + c.userData.floatOffset) * 0.05;
            });

            photoParticles.forEach(p => { p.mesh.lookAt(camera.position); });
            particles.forEach(p => { 
                if(p.type === 'dust') p.mesh.scale.multiplyScalar(1 + Math.sin(time * 5 + p.treePos.x)*0.005); 
            });

            if(composer) composer.render(); else renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
